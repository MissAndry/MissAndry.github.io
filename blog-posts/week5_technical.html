<!DOCTYPE html>
<html>
<head>
	<title>MissAndry</title>
	<link rel="stylesheet" type="text/css" href="cherry_template.css">
	<link href='http://fonts.googleapis.com/css?family=Roboto+Slab:400,100,300,700|Lobster' rel='stylesheet' type='text/css'>
	
</head>
<body>
	<header>
		<h1>MissAndry</h1>
	
		<nav>
			<ul>
				<li><a href="http://missandry.github.io">home</a></li>
				<li><a href="http://missandry.github.io/blog-posts/tech-archive.html">tech blog</li>
				<li><a href="http://missandry.github.io/blog-posts/culture-archive.html">culture blog</li>
				<li><a href="http://missandry.github.io/projects.html">projects</a></li>
			</ul>
		</nav>
	</header>
	<div id="wrapper">
		<h2>Gettin' Classy</h2>
		<!-- <img src="SO CLASSY" /> -->
		<hr />
		<p>
			Well before anyone gets into writing Ruby classes, they learn how to call methods on a class. An array, for example, has access to all manner of built-in methods. These methods work for any array, any time. That's because any new array is technically a new <em>instance</em> of the <em>Array class</em>.  
		</p> 
		<img src="../unit1_projects/images/week-5/new_array.png" />
		<p>
			From here, you can call different methods on the array like #push and #sort. Those are methods built-in to the Array class and will work on any array.
		</p>
		<img src="../unit1_projects/images/week-5/array_methods.png" />
		<img src="../unit1_projects/images/week-5/more_array_methods.png" />
		<p>
			While creating instances of built-in classes is super cool, it can get really boring to call the same three classes all the time. Luckily, Ruby is dynamic enough to allow a user to write new classes with its own methods. 
		</p>
		<p>
			Writing your own class is useful when you want to define specific behaviors for a specific type of object and call on those behaviors many times. 
		</p>
		<p>
			For example, if you wanted to create a virtual dinosaur (and I don't mean an obsolete OS), you could start off like this:
		</p>
		<img src="../unit1_projects/images/week-5/initialize_dino.png" />
		<p>
			The first line - class Dino - tells Ruby that you want to create a class called Dino. The first method you'll want to write in any class is the <em>initialize</em> method. Anything you write in here will load as soon as you call a new instance of the class, and any arguments you give to initialize can be arguments you pass to a new instance of the class.
		</p>
		<img src="../unit1_projects/images/week-5/reptar.png" />
		<p>
			After initialize, you can write any methods you want class instances to be able to perform. If you want your dinosaurs to roar, you can include a roar method. Likewise, if you want to print your chances of winning a fight against a dinosaur, you can include that method as well. 
		</p>
		<img src="../unit1_projects/images/week-5/roar_talons.png" />
		<p>
			The @ sign in front of the variable names in initialize and talon_count signal to Ruby that you want that variable to be accessible by all methods within the class. That way, you don't have to keep passing the same arguments to the class methods. talon_count accepts no arguments but still handles the instance variables flawlessly.
		</p>
		<img src="../unit1_projects/images/week-5/new_dinos.png" />
		<p>
			Now you can build a whole menagerie of basic dinosaurs that all roar and all have some amount of talons, and you only have to write the roar and talon_count functions once!
		</p>
		<p class="date">8.17.2014</p>
		<div class="push"></div>
	</div>

	<footer>&copy; MissAndry</footer>
</body>
</html>